<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Advanced MP4 Viewer – Movable Controls</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; background: #000; color: #fff;
    overflow: hidden; 
  }
  
  #app-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    background: #000;
  }

  #player-container {
    position: relative; width: 100%; height: 100%;
    display: flex; align-items: center; justify-content: center;
    overflow: hidden; 
  }
  video {
    width: 100%; height: auto; max-height: 100%;
    object-fit: contain; background: #000;
    transform-origin: center center;
    transition: transform 0.05s linear;
    will-change: transform;
    touch-action: none;
  }
  
  video.can-pan { cursor: grab; }
  video.is-panning { cursor: grabbing; }
  video.can-seek { cursor: ew-resize; }
  video.can-contrast { cursor: ns-resize; }

  .controls-overlay {
    position: absolute;
    bottom: 10px; left: 10px;
    width: 600px; 
    height: 115px;
    max-width: calc(100% - 20px);
    max-height: calc(100% - 20px);
    z-index: 10;
    display: flex; flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    align-items: center;
    background: rgba(0,0,0,0.6);
    padding: 20px 10px 10px 10px;
    border: 1px solid #555;
    border-radius: 12px;
    user-select: none;
    transition: opacity 0.3s;
    resize: both;
    overflow: auto; 
    cursor: move;
  }
  
  #timeline-container {
    position: absolute;
    top: 10px; 
    left: 10px; right: 10px;
    height: 14px;
    background: rgba(100, 100, 100, 0.5);
    border-radius: 7px;
    cursor: pointer;
    z-index: 11;
    transition: opacity 0.3s;
  }
  #timeline-progress {
    height: 100%; width: 0%;
    background: #2fa8ff;
    border-radius: 7px;
    pointer-events: none;
  }

  button {
    background: #222; color: #fff; border: 1px solid #555;
    border-radius: 6px; padding: 8px 10px; cursor: pointer;
    transition: 0.2s; font-size: 1rem;
  }
  button:hover { background: #2fa8ff; color: #000; }
  .control { 
    display: flex; flex-direction: column; align-items: center; 
    font-size: 0.8rem; min-width: 50px;
    cursor: default;
  }
  input[type="range"] {
    cursor: pointer;
  }
  
  #speed { width: 180px; }
  #zoom { width: 120px; }
  #zoom-level { font-weight: bold; }
  datalist { display: flex; justify-content: space-between; color: #aaa; font-size: 0.75rem; }

  @media(max-width: 768px){
    .controls-overlay {
      bottom: 5px !important; 
      left: 5px !important; 
      right: 5px !important;
      top: auto !important;
      width: auto !important;
      height: auto !important;
      resize: none !important;
      overflow-x: auto !important;
      overflow-y: hidden !important;
      flex-wrap: nowrap !important;
      justify-content: flex-start !important;
      padding-top: 15px;
      padding-bottom: 15px;
      cursor: default !important;
    }
    .control {
      flex-direction: column;
      min-width: 80px;
    }
    input[type="range"] { width: 70px; }
    #speed { width: 100px; } 
    #zoom { width: 70px; }
  }
</style>
</head>
<body>
  
  <div id="app-wrapper">
    <div id="player-container">
      <video id="video" preload="auto" autoplay muted playsinline crossorigin="anonymous"></video>
      
      <div id="timeline-container">
        <div id="timeline-progress"></div>
      </div>
    </div>

    <div class="controls-overlay" id="controls">
      <button id="playPause">⏸️</button>
      <button id="frameBack">⏪</button>
      <button id="frameForward">⏩</button>
      <button id="fullscreen">⛶</button>
      
      <div class="control">
        <label>Zoom (<span id="zoom-level">1.0</span>x)</label>
        <input type="range" id="zoom" min="1" max="10" step="0.1" value="1" />
      </div>
      <div class="control">
        <label>Contrast</label>
        <input type="range" id="contrast" min="0.5" max="2" step="0.1" value="1" />
      </div>
      <div class="control">
        <label>Speed</label>
        <input type="range" id="speed" min="0.25" max="2" step="0.25" value="1" list="speedticks" />
        <datalist id="speedticks">
          <option value="0.25" label="¼x"></option>
          <option value="0.5" label="½x"></option>
          <option value="1" label="1x"></option>
          <option value="1.5" label="1½x"></option>
          <option value="2" label="2x"></option>
        </datalist>
      </div>
      <div class="control">
        <label>Bright</label>
        <input type="range" id="brightness" min="0.5" max="2" step="0.1" value="1" />
      </div>
      <div class="control">
        <label>Saturate</label>
        <input type="range" id="saturate" min="0" max="2" step="0.1" value="1" />
      </div>
    </div>
  </div>

<script>
const appWrapper = document.getElementById('app-wrapper');
const video = document.getElementById('video');
const controls = document.getElementById('controls');
const playerContainer = document.getElementById('player-container');
const timelineContainer = document.getElementById('timeline-container');
const timelineProgress = document.getElementById('timeline-progress');
const playPauseButton = document.getElementById('playPause');

let stepping = false;
let hideTimer;
let isSeekingTimeline = false;
let dragMouseOffset = { x: 0, y: 0 };

// ---- Load & Save Controls Position ----
let controlsState = {};
const controlsStorageKey = 'mp4ViewerControlsState';

function saveControlsState() {
  if (window.innerWidth <= 768) return;
  localStorage.setItem(controlsStorageKey, JSON.stringify(controlsState));
}

function resetControlsPosition() {
  controlsState = { bottom: '10px', left: '10px', top: 'auto', right: 'auto' };
  controls.style.bottom = controlsState.bottom;
  controls.style.left = controlsState.left;
  controls.style.top = controlsState.top;
  controls.style.right = controlsState.right;
}

function loadControlsState() {
  const savedState = localStorage.getItem(controlsStorageKey);
  if (savedState && window.innerWidth > 768) {
    controlsState = JSON.parse(savedState);
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    const top = parseFloat(controlsState.top);
    const left = parseFloat(controlsState.left);

    if (top > winH - 50 || left > winW - 50 || top < -50 || left < -50) {
      resetControlsPosition();
    } else {
      controls.style.top = controlsState.top || 'auto';
      controls.style.left = controlsState.left || '10px';
      controls.style.bottom = controlsState.bottom || '10px';
      controls.style.right = controlsState.right || 'auto';
      controls.style.width = controlsState.width || '600px';
      controls.style.height = controlsState.height || '115px';
    }
  } else {
    resetControlsPosition();
  }
}
loadControlsState();

// ---- ResizeObserver to save size ----
const controlsResizeObserver = new ResizeObserver(entries => {
  if (window.innerWidth <= 768) return;
  const rect = entries[0].contentRect;
  controlsState.width = `${rect.width}px`;
  controlsState.height = `${rect.height}px`;
  saveControlsState();
});
controlsResizeObserver.observe(controls);

// ---- Drag logic for controls panel ----
function onControlsDragStart(e) {
  if (window.innerWidth <= 768) return;
  
  const target = e.target;
  if (target.closest('button, input, datalist, label, .control')) {
      return; 
  }
  const rect = controls.getBoundingClientRect();
  if (e.clientX > rect.right - 20 && e.clientY > rect.bottom - 20) {
      return; 
  }
  
  e.preventDefault();
  
  controls.style.bottom = 'auto';
  controls.style.right = 'auto';
  controls.style.top = `${rect.top}px`;
  controls.style.left = `${rect.left}px`;
  
  const coords = getEventCoords(e);
  dragMouseOffset.x = coords.x - rect.left;
  dragMouseOffset.y = coords.y - rect.top;
  
  document.addEventListener('mousemove', onControlsDragMove);
  document.addEventListener('mouseup', onControlsDragEnd);
  document.addEventListener('touchmove', onControlsDragMove, { passive: false });
  document.addEventListener('touchend', onControlsDragEnd);
}

function onControlsDragMove(e) {
  e.preventDefault();
  const coords = getEventCoords(e);
  
  let newLeft = coords.x - dragMouseOffset.x;
  let newTop = coords.y - dragMouseOffset.y;
  
  const winW = window.innerWidth;
  const winH = window.innerHeight;
  const panelW = controls.offsetWidth;
  const panelH = controls.offsetHeight;
  
  newLeft = Math.max(0, Math.min(newLeft, winW - panelW));
  newTop = Math.max(0, Math.min(newTop, winH - panelH));
  
  controls.style.left = `${newLeft}px`;
  controls.style.top = `${newTop}px`;
}

function onControlsDragEnd() {
  document.removeEventListener('mousemove', onControlsDragMove);
  document.removeEventListener('mouseup', onControlsDragEnd);
  document.removeEventListener('touchmove', onControlsDragMove);
  document.removeEventListener('touchend', onControlsDragEnd);
  
  controlsState.top = controls.style.top;
  controlsState.left = controls.style.left;
  controlsState.bottom = 'auto';
  controlsState.right = 'auto';
  saveControlsState();
}

controls.addEventListener('mousedown', onControlsDragStart);
controls.addEventListener('touchstart', onControlsDragStart, { passive: false });


// ---- Load video safely ----
(async function loadVideo() {
  const url = "https://cs.apac.trusttalk.net/83837/1.3.46.670589.29.18771927773542520251023181930302_1.3.46.670589.29.1877192777354251340570154739598612.mp4";
  try {
    const resp = await fetch(url, {mode:"cors"});
    if (!resp.ok) throw new Error("CORS blocked");
    video.src = url;
  } catch {
    video.src = "https://corsproxy.io/?" + encodeURIComponent(url);
  }
})();

// ---- Draggable Timeline Controls ----
video.addEventListener('timeupdate', () => {
  if (video.duration && !isSeekingTimeline) {
    const percent = (video.currentTime / video.duration) * 100;
    timelineProgress.style.width = `${percent}%`;
  }
});
function getTimelinePercent(e) {
  const bounds = timelineContainer.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const percent = (clientX - bounds.left) / bounds.width;
  return Math.max(0, Math.min(1, percent));
}
function handleTimelineSeek(e) {
  if (!video.duration) return;
  const percent = getTimelinePercent(e);
  video.currentTime = percent * video.duration;
  timelineProgress.style.width = `${percent * 100}%`;
}
function onTimelineDragStart(e) {
  e.preventDefault();
  isSeekingTimeline = true;
  handleTimelineSeek(e);
  document.addEventListener('mousemove', onTimelineDragMove);
  document.addEventListener('mouseup', onTimelineDragEnd);
  document.addEventListener('touchmove', onTimelineDragMove, { passive: false });
  document.addEventListener('touchend', onTimelineDragEnd);
}
function onTimelineDragMove(e) {
  if (!isSeekingTimeline) return;
  e.preventDefault();
  handleTimelineSeek(e);
}
function onTimelineDragEnd() {
  isSeekingTimeline = false;
  document.removeEventListener('mousemove', onTimelineDragMove);
  document.removeEventListener('mouseup', onTimelineDragEnd);
  document.removeEventListener('touchmove', onTimelineDragMove);
  document.removeEventListener('touchend', onTimelineDragEnd);
}
timelineContainer.addEventListener('mousedown', onTimelineDragStart);
timelineContainer.addEventListener('touchstart', onTimelineDragStart, { passive: false });

// ---- Filters ----
const filters = { brightness: 1, contrast: 1, saturate: 1 };
const contrastSlider = document.getElementById('contrast');
function updateFilter() {
  video.style.filter = `brightness(${filters.brightness}) contrast(${filters.contrast}) saturate(${filters.saturate})`;
}
document.getElementById('brightness').addEventListener("input",e=>{
  filters.brightness=e.target.value; updateFilter();
});
contrastSlider.addEventListener("input",e=>{
  filters.contrast=e.target.value; updateFilter();
});
document.getElementById('saturate').addEventListener("input",e=>{
  filters.saturate=e.target.value; updateFilter();
});

// ---- Speed slider ----
const speedSlider = document.getElementById('speed');
speedSlider.addEventListener('input', e => {
  const step = Math.round(e.target.value * 4) / 4;
  e.target.value = step;
  video.playbackRate = step;
});

// ---- Play / Pause ----
playPauseButton.onclick = () => {
  if (video.paused) {
    video.play().catch(e => console.error("Play error:", e));
  } else {
    video.pause();
  }
  showControls();
};
video.addEventListener('play', () => {
  playPauseButton.textContent = '⏸️';
});
video.addEventListener('pause', () => {
  playPauseButton.textContent = '▶️';
});

// ---- Simple Step (0.25s) ----
function stepFrame(dir) {
  if (stepping) return;
  stepping = true;
  video.pause();
  showControls();
  const onSeeked = () => {
    video.removeEventListener('seeked', onSeeked);
    video.removeEventListener('error', onSeeked);
    stepping = false;
  };
  video.addEventListener('seeked', onSeeked);
  video.addEventListener('error', onSeeked);
  const offset = dir * 0.25;
  let target = Math.max(0, video.currentTime + offset);
  if (target >= video.duration) target = video.duration;
  video.currentTime = target;
}
document.getElementById('frameForward').onclick = () => stepFrame(1);
document.getElementById('frameBack').onclick = () => stepFrame(-1);

// ---- Fullscreen ----
document.getElementById('fullscreen').onclick = ()=>{
  if(!document.fullscreenElement) {
    appWrapper.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
};
document.addEventListener('fullscreenchange', () => {
  if (!document.fullscreenElement) {
    showControls();
  }
});

// ---- Zoom, Pan, & Gesture State ----
const zoomSlider = document.getElementById('zoom');
const zoomLevelLabel = document.getElementById('zoom-level');
let gesture = {
  scale: 1, x: 0, y: 0, lastX: 0, lastY: 0,
  startX: 0, startY: 0, isDragging: false, isZooming: false,
  dragMode: 'none', startPinchDist: 0,
  lastContrast: filters.contrast, lastSeekTime: video.currentTime,
  // **NEW**: Track time and movement for tap-to-play
  startTime: 0, totalDeltaX: 0, totalDeltaY: 0
};

function updateTransform() {
  video.style.transition = gesture.isDragging ? 'none' : 'transform 0.05s linear';
  video.style.transform = `translate(${gesture.x}px, ${gesture.y}px) scale(${gesture.scale})`;
}

zoomSlider.addEventListener('input', e => {
  gesture.scale = parseFloat(e.target.value);
  zoomLevelLabel.textContent = gesture.scale.toFixed(1);
  if (gesture.scale <= 1) {
    gesture.x = 0; gesture.y = 0;
    gesture.lastX = 0; gesture.lastY = 0;
    video.classList.remove('can-pan');
  } else {
    video.classList.add('can-pan');
  }
  updateTransform();
});

function getEventCoords(e) {
  return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
}
function getPinchDist(e) {
  const dx = e.touches[0].clientX - e.touches[1].clientX;
  const dy = e.touches[0].clientY - e.touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

function onDragStart(e) {
  if (e.touches && e.touches.length === 2) {
    onPinchStart(e); return;
  }
  if (gesture.isZooming) return;
  
  gesture.isDragging = true;
  const coords = getEventCoords(e);
  gesture.startX = coords.x;
  gesture.startY = coords.y;
  gesture.lastX = gesture.x;
  gesture.lastY = gesture.y;
  gesture.lastContrast = filters.contrast;
  gesture.lastSeekTime = video.currentTime;
  
  // **NEW**: Reset tap-to-play trackers
  gesture.startTime = Date.now();
  gesture.totalDeltaX = 0;
  gesture.totalDeltaY = 0;
  
  if (gesture.scale > 1) {
    gesture.dragMode = 'pan';
    video.classList.add('is-panning');
  } else {
    gesture.dragMode = 'pending';
  }
  showControls();
  clearTimeout(hideTimer);
  if (e.touches) e.preventDefault();
}

function onDragMove(e) {
  if (e.touches && e.touches.length === 2) {
    onPinchMove(e); return;
  }
  if (!gesture.isDragging || gesture.isZooming) return;
  if (e.touches) e.preventDefault();

  const coords = getEventCoords(e);
  const deltaX = coords.x - gesture.startX;
  const deltaY = coords.y - gesture.startY;
  
  // **NEW**: Update total movement for tap check
  gesture.totalDeltaX = deltaX;
  gesture.totalDeltaY = deltaY;

  if (gesture.dragMode === 'pan') {
    gesture.x = gesture.lastX + deltaX;
    gesture.y = gesture.lastY + deltaY;
    updateTransform();
  } else {
    if (gesture.dragMode === 'pending') {
      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        gesture.dragMode = 'seek';
        video.classList.add('can-seek');
      } else {
        gesture.dragMode = 'contrast';
        video.classList.add('can-contrast');
      }
    }
    
    if (gesture.dragMode === 'seek') {
      const seekAmount = (deltaX / window.innerWidth) * 20; 
      const newTime = Math.max(0, Math.min(video.duration, gesture.lastSeekTime + seekAmount));
      video.currentTime = newTime;
      if (video.duration) {
        timelineProgress.style.width = `${(newTime / video.duration) * 100}%`;
      }
      
    } else if (gesture.dragMode === 'contrast') {
      const contrastChange = -(deltaY / window.innerHeight) * 1.5;
      const newContrast = Math.max(0.5, Math.min(2, gesture.lastContrast + contrastChange));
      filters.contrast = newContrast;
      contrastSlider.value = newContrast;
      updateFilter();
    }
  }
}

function onDragEnd(e) {
  // **NEW**: Check for tap-to-play
  const timeElapsed = Date.now() - gesture.startTime;
  const dragDistance = Math.sqrt(gesture.totalDeltaX * gesture.totalDeltaX + gesture.totalDeltaY * gesture.totalDeltaY);

  // Check for a 'tap' (short duration, minimal movement, not a zoom)
  if (timeElapsed < 250 && dragDistance < 10 && !gesture.isZooming) {
    playPauseButton.click();
  }

  // --- Rest of the function ---
  if (e.touches && e.touches.length > 0) return;
  
  if (gesture.isDragging) {
    if (gesture.dragMode === 'pan') {
      gesture.lastX = gesture.x;
      gesture.lastY = gesture.y;
    }
  }
  gesture.isDragging = false;
  gesture.isZooming = false;
  gesture.dragMode = 'none';
  video.classList.remove('is-panning', 'can-seek', 'can-contrast');
  showControls();
}

function onPinchStart(e) {
  if (!e.touches || e.touches.length !== 2) return;
  e.preventDefault();
  gesture.isZooming = true;
  gesture.isDragging = false;
  gesture.startPinchDist = getPinchDist(e);
  showControls();
  clearTimeout(hideTimer);
}

function onPinchMove(e) {
  if (!e.touches || e.touches.length !== 2 || !gesture.isZooming) return;
  e.preventDefault();
  
  const newDist = getPinchDist(e);
  const scaleChange = newDist / gesture.startPinchDist;
  
  let newScale = gesture.scale * scaleChange;
  newScale = Math.max(1, Math.min(10, newScale));
  
  gesture.scale = newScale;
  zoomSlider.value = newScale;
  zoomLevelLabel.textContent = newScale.toFixed(1);

  if (newScale <= 1) {
    gesture.x = 0; gesture.y = 0;
    gesture.lastX = 0; gesture.lastY = 0;
    video.classList.remove('can-pan');
  } else {
    video.classList.add('can-pan');
  }
  updateTransform();
  gesture.startPinchDist = newDist;
}

video.addEventListener('mousedown', onDragStart);
document.addEventListener('mousemove', onDragMove);
document.addEventListener('mouseup', onDragEnd);
video.addEventListener('touchstart', onDragStart, { passive: false });
document.addEventListener('touchmove', onDragMove, { passive: false });
document.addEventListener('touchend', onDragEnd);
document.addEventListener('touchcancel', onDragEnd);


// ---- Auto-hide controls ----
function showControls() {
  controls.style.opacity = 1;
  timelineContainer.style.opacity = 1;
  clearTimeout(hideTimer);
  hideTimer = setTimeout(()=> {
    // Don't hide if timeline is being dragged
    if (!video.paused && !stepping && !gesture.isDragging && !gesture.isZooming && !isSeekingTimeline) {
      controls.style.opacity = 0;
      timelineContainer.style.opacity = 0;
    }
  }, 2500);
}
document.addEventListener('mousemove', showControls);
document.addEventListener('touchstart', showControls, { passive: true });
video.addEventListener('pause', showControls);
video.addEventListener('play', showControls);
showControls();

// ---- Keyboard shortcuts ----
document.addEventListener('keydown',e=>{
  if (e.target.type === 'range') return;
  switch(e.key){
    case ' ': e.preventDefault(); document.getElementById('playPause').click(); break;
    case 'ArrowRight': stepFrame(1); break;
    case 'ArrowLeft': stepFrame(-1); break;
    case 'f': document.getElementById('fullscreen').click(); break;
  }
});

video.addEventListener("loadeddata",()=>video.play().catch(()=>{}));
</script>
</body>
</html>
